#!KAMAILIO
include_file "/tmp/kamailio-local.cfg"

#!define FLG_HOMER_TRACE 22
#!define FLG_ROUTER_OK 23
#!define FLG_FROM_ROUTER 24
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7
#!define FLT_NATS 5

# set max while loops for APIBAN ref (https://www.apiban.org/doc.html#kamailioex)
max_while_loops=250

# Set the server to try to locate outbound interface on multihomed host.
mhomed=1

use_dns_cache=off
dns_try_naptr=on

# If set to 1 (default value) a 'Warning' header is added to each reply generated by Kamailio.
# The header contains several details that help troubleshooting using the network traffic dumps,
# but might reveal details of your network infrastructure and internal SIP routing.
#!ifdef WITH_DEBUG
sip_warning=1
#!else
sip_warning=0
#!endif

# LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=1
log_stderror=no
#!endif

log_facility=LOG_LOCAL0
tcp_accept_no_cl=yes
children=16

# TLS (if defined in kamailio-local "#!define WITH_TLS")
#!ifdef WITH_TLS
enable_tls=yes
loadmodule "tls.so"
#!else
enable_tls=no
#!endif

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"


# -----------------------------------------------------------------------------
# load modules
# -----------------------------------------------------------------------------
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "keepalive.so"
loadmodule "maxfwd.so"
loadmodule "pv.so"
loadmodule "sanity.so"
loadmodule "sl.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "xlog.so"
loadmodule "ctl.so"
loadmodule "jsonrpcs.so"
loadmodule "json.so"
loadmodule "rr.so"
loadmodule "siputils.so"
loadmodule "htable.so"
loadmodule "permissions.so"
loadmodule "pike.so"
loadmodule "xhttp.so"
loadmodule "exec.so"
loadmodule "cfgutils.so"
loadmodule "ipops.so"
loadmodule "db_postgres.so"
loadmodule "dispatcher.so"
loadmodule "domain.so"
loadmodule "dialplan.so"
loadmodule "avpops.so"
loadmodule "path.so"
loadmodule "http_client.so"
loadmodule "jansson.so"
loadmodule "rtimer.so"
loadmodule "ndb_redis.so"
loadmodule "topos.so"
loadmodule "topos_redis.so"
loadmodule "sqlops.so"
loadmodule "dialog.so"
#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
#!endif
loadmodule "nathelper.so"
loadmodule "kex.so"
loadmodule "http_async_client.so"
loadmodule "acc.so"
loadmodule "uac.so"
loadmodule "sdpops.so"
loadmodule "siptrace.so"


# -----------------------------------------------------------------------------
# modparam
# -----------------------------------------------------------------------------
modparam("xlog", "buf_size", 8192);
modparam("domain", "db_url", DBURL)
modparam("domain", "register_myself", 1)
modparam("dialplan", "db_url", DBURL)
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 1)
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@nethvoice.it")
// modparam("dispatcher", "flags", 2) # If flag 2 is set, then failover support is enabled. The functions exported by the module will store the rest of addresses from the destination set in the AVP, and use these AVPs to contact next address if the current-tried destination fails.
modparam("dispatcher", "ds_probing_mode", 2) # Value 2: if set to 2, only gateways in INACTIVE state with PROBING mode set are tested.
modparam("dispatcher", "ds_ping_interval", 30) #With this parameter you can defined the interval for sending a request to a gateway marked as inactive upon a failed request routing to it. This parameter is only used, when the TM-Module is loaded. If set to “0”, the pinging of inactive gateway is disabled.
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=403;code=488;code=401;class=3") #This parameter defines the valid response codes, which are accepted as a valid reply to the PING-Method. It is a list separated by colons, whery you may define either a single code (e.g. "code=202" would accept 202 as an additional, valid response) or a class of responses, you want to accept (e.g. "class=2" would accept everything from 200 to 299 as valid response). This parameter can be modified via ser config framework.
modparam("dispatcher", "flags", 2) #If flag 2 is set, then failover support is enabled. The functions exported by the module will store the rest of addresses from the destination set in the AVP, and use these AVPs to contact next address if the current-tried destination fails.
modparam("htable", "htable", "userblocklist=>size=8;autoexpire=300;")
modparam("htable", "htable", "ipban=>size=20;autoexpire=300;")
modparam("htable", "htable", "apiban=>size=11;")
modparam("htable", "htable", "apibanctl=>size=1;initval=0;")
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)
modparam("sanity", "autodrop", 0)
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", FR_TIMEOUT_100) # default retransmission timeout: 5 sec
modparam("tm", "fr_inv_timer", FR_INV_TIMEOUT) # default invite retransmission timeout after 1xx: 60 sec
modparam("tm", "retr_timer1", RETR_TIMER1)
modparam("tm", "retr_timer2", RETR_TIMER2)
# Time period in seconds used for sampling (or the sampling accuracy).
# The smaller the better, but slower. If you want to detect peeks, use a small one.
# To limit the access (like total number of requests on a long period of time) to a proxy resource
# (a gateway for example), use a bigger value of this parameter.
modparam("pike", "sampling_time_unit", 2)
# How many requests should be allowed per sampling_time_unit before blocking all the incoming request from that IP.
# Practically, the blocking limit is between ( let's have x=reqs_density_per_unit) x and 3*x for IPv4 addresses
# and between x and 8*x for IPv6 addresses.
modparam("pike", "reqs_density_per_unit", 50)
# Specifies for how long the IP address will be kept in memory after the last request from that IP address.
# It's a sort of timeout value, in seconds. Note that it is not the duration to keep the IP in state 'blocked'.
# An IP is unblocked next occurrence of 'sampling_time_unit' that does not exceed 'reqs_density_per_unit'.
# Keeping an IP in memory results in faster reaching of blocked state -- see the notes about the limits of getting to state 'blocked'.
modparam("pike", "remove_latency", 4)
//modparam("topos", "db_url", DBURL) TODO: check, if topos is in redis, unneeded
modparam("ndb_redis", "server", NDB_REDIS_SERVER)
modparam("topos", "storage", "redis")
modparam("topos", "dialog_expire", 12600)
modparam("topos_redis", "serverid", "srv1")
#!ifdef WITH_RTPENGINE
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "rtp_inst_pvar", "$avp(RTP_INSTANCE)")
#!endif
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
modparam("keepalive", "ping_interval", 60)
modparam("keepalive", "ping_from", PING_FROM)
modparam("keepalive", "delete_counter", 5)
modparam("http_async_client", "workers", 2)
modparam("uac", "restore_dlg", 1)
modparam("pv", "shvset", "debug=i:1")
modparam("pv", "shvset", "fakeprack=i:0")
#!ifdef WITH_TLS
modparam("tls", "config", "/etc/kamailio/tls/")
#!endif
modparam("siptrace", "trace_mode", 1)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_on", 0)
modparam("siptrace", "duplicate_uri", "sip:127.0.0.1:5065")
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "hep_version", 2)
modparam("siptrace", "hep_capture_id", 1)

# -----------------------------------------------------------------------------
# Routing Logic
# -----------------------------------------------------------------------------
request_route {
    $var(destinationXavp) = "";
    #checking if it's for me
    if (uri!=myself && is_method("INVITE|REGISTER") && !ds_is_from_list() && !has_totag()) {
        xlog('L_WARN', "[DEV] - $ci $rm-$cs - request not for me, rejecting! \n");
        #sl_send_reply("404","Not here");
        exit;
    }
    # SIP initial check
    route(REQINIT);
    # local healtcheck
    route(HEALTHCHECK);
    # manage dialog module
    dlg_manage();

    if (!is_method("UPDATE")){
        if (is_in_subnet($si, INTERNAL_NETWORK) || $si == "127.0.0.1" ) {
            $avp(direction) = "out";
        } else {
            $avp(direction) = "in";
        }
            if ($avp(direction) == "in") {
                # NAT detection
                route(NATDETECT);
            }
            $dlg_var(direction) = $avp(direction);
            $dlg_var(source_ip) = $si; // saving source IP for correct handling socket for reply
    }
    
    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }
    # handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }
    # handle requests within SIP dialogs
    route(WITHINDLG);
    if ($dlg_var(direction) == "out" && $hdr(Route) != $null) {
        // loose_route();
        # setting ru according to hdr(Route)
        $var(tmpdu)=$(hdr(Route){s.replace,<,});
        $var(tmpdu)=$(var(tmpdu){s.replace,>,});
        $du=$var(tmpdu);
	    $ru=$var(tmpdu);
        remove_hf("Route");
    }
    ### only initial requests (no To tag)
    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    if($dlg_var(direction)== "in") {
        remove_hf("Route");
    }
    if (is_method("INVITE|SUBSCRIBE|PUBLISH|NOTIFY|UPDATE")) {
        record_route();
    }
    # account only INVITEs
    // if (is_method("INVITE")) {
    //     setflag(FLT_ACC); # do accounting
    // }
    if ($rU==$null && !is_method("REGISTER") && !is_method("OPTIONS") && $dlg_var(direction) == "in") {
        # request with no Username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    route(KEEPALIVE);

    if($dlg_var(direction) == "in" && is_method("INVITE|REGISTER|SUBSCRIBE|PUBLISH|NOTIFY|UPDATE|OPTIONS|PRACK")){
        route(HANDLE_ALIAS);
        if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in direction is IN and method is in the list \n");
        route(GET_ASTERISK_NODE);
        if ($du == $null) {
            # logging that no destination was found
            if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - no destination found \n");
            # no destination found
            sl_send_reply("404","Not Found");
            exit;
        }
        $dlg_var(du) = $du;
        route(SET_TIMERS);
        route(RELAY);
    } else {
        # what could happen here ?
        # 1 - outbound call coming from one of the dispatcher setid (needs to be relayed)
        # 2 - inbound call for none (needs to be rejected)
        if ($dlg_var(direction) == "out") {
            # this call needs to be relayed
            if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in dialog and direction OUT, doing RELAY \n");
            if (is_method("REGISTER")) {
                route(REWRITE_CONTACT);
                // add_contact_alias();
            }
            route(RELAY);
            exit;
        } else {
            # this call needs to be dropped
            drop;
        }
    }
    exit;
} # end request_route

// TODO: check
# -----------------------------------------------------------------------------
# route[GET_ASTERISK_NODE]
# use dialplan to get the correct dispatcher id and use dispatcher to get the correct node
# TODO: dialplan il dominio e nel replace ID dispatcher
# -----------------------------------------------------------------------------
route[GET_ASTERISK_NODE] {
    # get the dispatcher id from dialplan using dp_translate function
    $var(ret) = $null;
    $var(dispatcher_id) = $null;
    dp_replace(1,"$rd","$var(dispatcher_id)");
    if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - dispatcher_id: $var(dispatcher_id) \n");
    if($var(dispatcher_id) == 0 || $var(dispatcher_id) == $null) {
        # checking if it's an inbound trunk call, using dp_replace with 2 as first parameter and ru as second
        dp_replace(2,"$ru","$var(dispatcher_id)");
        if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - dispatcher_id: $var(dispatcher_id) \n");
        if ($var(dispatcher_id) == 0 || $var(dispatcher_id) == $null) {
            # no dispatcher id found, drop the call
            if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - no dispatcher id found, dropping the call \n");
            return;
        }
    }
    # get the correct node from dispatcher
    ds_select_dst("$var(dispatcher_id)",8);
    if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - asterisk_node: $var(asterisk_node) \n");

}

# -----------------------------------------------------------------------------
# route[KEEPALIVE]
# reply back 200 ok for keepalive options
# -----------------------------------------------------------------------------
route[KEEPALIVE] {
    if (is_method("OPTIONS") && uri==myself && $rU==$null && $hdr(Route) == $null) {
        sl_send_reply("200","Keepalive");
        exit;
    }
} # end route[KEEPALIVE]

# -----------------------------------------------------------------------------
# route[PIKE]
# handle pike module implementation
# -----------------------------------------------------------------------------
route[PIKE] {
    if ($sht(ipban=>$si)!=$null) {
        # ip is already blocked - keep the node warm
        pike_check_req();
        xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    if (!pike_check_req()) {
        $avp(ipaddressToBan) = $si;
        route(ADD_TO_IPBAN);
        #$sht(ipban=>$si) = 1;
        xlog("L_ALERT","(route[PIKE]) pike block $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
} # end route[PIKE]

# -----------------------------------------------------------------------------
# route[WITHINDLG]
# Handle requests within SIP dialogs
# -----------------------------------------------------------------------------
route[WITHINDLG] {
    if (!has_totag()) {
        return;
    }
    if ($shv(debug) == 1 ) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in WITHINDLG route \n");

    if (loose_route()) {
        if ($shv(debug) == 1 ) xlog('L_WARN', "[DEV] - $ci $rm-$cs - loose_route is OK, doing DLGURI \n");
        route(DLGURI);
        if ( is_method("ACK") ) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if ( is_method("NOTIFY") ) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        # handling advanced NAT if this packet goes to private IP address and direction is OUT
        // if($ru{uri.host})
        if ($shv(debug) == 1 ) xlog('L_WARN', "[DEV] - $ci $rm-$cs - doing RELAY with destination : ru: $ru du: $du , host : $(ru{uri.host})\n");
        route(RELAY);
        exit;
    }
    if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - after check of loose_route (if you don't see loose_route is OK means it returned false) \n");
    if(is_method("PRACK")) {
        if($shv(fakeprack) == 1) {
            if ($shv(debug) == 1 ) xlog('L_WARN', "[DEV] - $ci $rm-$cs - PRACK received and shv fakeprack is set, sending 200 OK and not relaying \n");
            sl_send_reply("200","OK");
            exit;
        }

        if ($shv(debug) == 1 && is_method("PRACK")) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in WITHINDLG , loose_route not OK and it's a PRACK, relaying \n");
        // route(NATMANAGE);
        route(RELAY);
        exit;
    }
    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK / PRACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
} # end route[WITHINDLG]

# -----------------------------------------------------------------------------
# route[RELAY]
# Wrapper for relaying requests
# -----------------------------------------------------------------------------
route[RELAY] {
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    #rewriting user agent if coming from destination
    // if ($dlg_var(direction) == "out") {
    //     route(REWRITE_USER_AGENT);
    // }
    if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in RELAY route \n");
    if (is_method("INVITE|REGISTER|BYE|SUBSCRIBE|PUBLISH|NOTIFY|UPDATE|OPTIONS")) {
        if (!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|REGISTER|SUBSCRIBE|PUBLISH|NOTIFY|UPDATE|BYE")) {
        if (!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }

    if (is_method("INVITE|REGISTER")) {
        if (!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
} # end route[RELAY]

# -----------------------------------------------------------------------------
# route[REQINIT]
# Per SIP request initial checks
# -----------------------------------------------------------------------------
route[REQINIT] {
    # no connect for sending replies
    set_reply_no_connect();
    # enforce symmetric signaling
    # - send back replies to the source address of request
    force_rport();
    if ($ua =~ "friendly|sundayddr|scanner|sip-scan|SIPScan|sipsak|sipcli|sipv|VaxSIPUserAgent|VaxIPUserAgent|SIVuS|smap") {
        # silent drop for scanners - uncomment next line if want to reply
        # sl_send_reply("200", "OK");
        xlog("L_INFO","[R-REQINIT]: script kiddies from IP:$si:$sp - dropping and blocking\n");
        route(BLOCKIP);
        exit;
    }
    if ($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
        xlog("L_INFO","[R-REQINIT]: sql injection from IP:$si:$sp - dropping\n");
        route(BLOCKIP);
        exit;
    }
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }
    if (!sanity_check("17895", "7")) {
        xlog("$ci $rm-$cs Malformed SIP request from $si:$sp\n");
        exit;
    }

    #setting rtpengine
    $shv(rtpengine) = 't';

} # end route[REQINIT]

# -----------------------------------------------------------------------------
# route[NATDETECT]
# Caller NAT detection
# -----------------------------------------------------------------------------
route[NATDETECT] {
#!ifdef WITH_NAT
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
            fix_nated_contact();
        } else {
            fix_nated_contact();
        }
        setflag(FLT_NATS);
    }
#!endif
    return;
} # end route[NATDETECT]

# -----------------------------------------------------------------------------
# route[NATMANAGE]
# RTPProxy control and signaling updates for NAT traversal
# -----------------------------------------------------------------------------
route[NATMANAGE] {

#!ifdef WITH_NAT
    if (is_reply() && nat_uac_test("19")){
        if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - [NATMANAGE] - is reply and nat_uac_test(19) is true, setting flag FLB_NAT \n");
        setbflag(FLB_NATB);
    }
    if (is_request()) {
        if (has_totag()) {
            if (check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }
#!ifdef WITH_RTPENGINE
    $var(rtpengine_conf) = "";
    # -------------------------------------------------------------------------------------------------------------------------
    # defining external > internal or internal > external
    # -------------------------------------------------------------------------------------------------------------------------
    # logging direction
    xlog('L_WARN', "[DEV] - $ci $rm-$cs - direction: $avp(direction) / $dlg_var(direction) ($rs) \n");
    if ((($avp(direction) == 'in' || $dlg_var(direction) == 'in') && is_request()) || (($avp(direction) == 'out' || $dlg_var(direction) == 'out') && is_reply()) ) {
        if (has_body("application/sdp")) {
            $var(rtpengine_conf) = "direction=external direction=internal " + $var(rtpengine_conf);
            if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - external - internal (rs: $rs)\n");
        }
    } else {
        if (has_body("application/sdp")) {
            $var(rtpengine_conf) = "direction=internal direction=external " + $var(rtpengine_conf);
            if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - internal - external (rs: $rs)\n");
        }
    }
    # -------------------------------------------------------------------------------------------------------------------------
    $var(rtpAppend) = "";
    $var(isTrunk) = "0";
    $var(isTrunk) = $hdr(isTrunk);
    if(is_method("INVITE") && $var(isTrunk) == "1"){
        // removing the isTrunk header
        remove_hf("isTrunk");
    }

    if(is_method("INVITE") && has_body("application/sdp") && $var(isTrunk) == "0"){
        if( (is_method("INVITE") && $avp(direction) == 'in' || $dlg_var(direction) == 'in')  && is_request() && (sdp_with_transport("RTP/SAVPF") || sdp_with_transport("RTP/SAVP"))) {
            if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - from external to internal !! doing SRTP to RTP if SRTP is present \n");
            $dlg_var(trascoding) = 't';
            $var(rtpAppend) = " RTP";
            $dlg_var(SRTPTranscode) = "1";
        }

        if(is_method("INVITE") && ($avp(direction) == 'in' || $dlg_var(direction) == 'in') && is_reply() && $dlg_var(SRTPTranscode) == "1" && $rs == "200") {
            if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - from internal to external !! doing RTP to SRTP if SRTP is present \n");
            $dlg_var(trascoding) = 't';
            $var(rtpAppend) = " SRTP";
        }

        if(is_method("INVITE") && ($avp(direction) == 'out' || $dlg_var(direction) == 'out')  && is_request()) {
            if($avp(failure) == "1"){
                if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - (FAILURE) from internal to external !! doing RTP ONLY \n");
                $dlg_var(trascoding) = 't';
                $var(rtpAppend) = " RTP";
                $dlg_var(SRTPTranscode) = "2";
            } else {
                if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - from internal to external !! doing RTP to SRTP if RTP is present \n");
                $dlg_var(trascoding) = 't';
                $var(rtpAppend) = " SRTP";
                $dlg_var(SRTPTranscode) = "2";
            }
        }

        if(is_method("INVITE") && ($avp(direction) == 'out' || $dlg_var(direction) == 'out') && is_reply() && $dlg_var(SRTPTranscode) == "2" && $rs == "200") {
            if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - from external to internal !! doing SRTP to RTP if RTP is present \n");
            $dlg_var(trascoding) = 't';
            $var(rtpAppend) = " RTP";
        }
    }

    if($dlg_var(trascoding) == 't') {
        # The customer may specify the list of codecs it wishes to use for transcoding.
        #    IF dlg_var(codecs) is empty it means that the customer has not specified the codecs
        #        and therefore we use the defaults: g729 + pcma + pcmu + gsm.
        #    ELSE it means that the customer has explicitly specified the codecs and so I have
        #        to iterate in the dlg_var(codecs) [each codec is separated by a comma] and build the $var(rtpengine_conf)
        if($dlg_var(codecs) == '') {
            #$var(rtpengine_conf) = "symmetric-codecs codec-transcode-g729 codec-transcode-pcma codec-transcode-pcmu codec-transcode-gsm";
            $var(rtpengine_conf) = "" + $var(rtpengine_conf) + $var(rtpAppend);
        } else {
            $var(i)=0;
            #$var(rtpengine_conf) = "symmetric-codecs";
            $var(rtpengine_conf) = $var(rtpengine_conf) +  "codec-strip-all codec-except-telephone-event";
            # example: dlg_var(codecs) = 'g729,g722,g711a'
            # {s.select,index,separator} --> $(dlg_var(codecs){s.select,0,,}) => g729
            while($(dlg_var(codecs){s.select,$var(i),,}) != '') {
                $var(rtpengine_conf) = "" + $var(rtpengine_conf) + " codec-except-" + $(dlg_var(codecs){s.select,$var(i),,}) + " codec-transcode-" + $(dlg_var(codecs){s.select,$var(i),,});
                $var(i) = $var(i) + 1;
            }
        }
    }

    if ($shv(rtpengine) == 't') {
        route(SET_SOCKET);
        # Adding loog protection and ICE removing
        $var(rtpengine_conf) = "" + $var(rtpengine_conf) + " ICE=remove";
        if (nat_uac_test("8")) {
            if (has_body("application/sdp")) {
                if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs ($rs) - calling rtpengine_manage: replace-origin replace-session-connection $var(rtpengine_conf) \n");
                rtpengine_manage("replace-origin replace-session-connection $var(rtpengine_conf)");
            }
        } else {
            if (has_body("application/sdp")) {
                if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs ($rs) - trust-address replace-origin replace-session-connection symmetric-codecs codec-transcode-all $var(rtpengine_conf) \n");
                rtpengine_manage("trust-address replace-origin replace-session-connection symmetric-codecs codec-transcode-all $var(rtpengine_conf)");
            }
        }
    }
#!endif
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        if($shv(debug) == 1) xlog('L_WARN', "[DEV] - [NATMANAGE] - FLT_NATS and FLB_NATB not set \n");
        return;
    }
    if (is_request()) {
        if (!has_totag()) {
            if (t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply() && !is_method("SUBSCRIBE")) {
        if (isbflagset(FLB_NATB)) {
            // set_contact_alias();
            if (is_first_hop()){
                set_contact_alias();
                if($shv(debug) == 1) xlog('L_WARN', "[DEV] - [NATMANAGE] - it's a reply with code $rs , not SUBSCRIBE and it is a first hop, setting contact alias \n");
            }
        }
    }
    if (isbflagset(FLB_NATB)) {
        # no connect message in a dialog involving NAT traversal
        if (is_request()) {
            # using set_forward_no_connect only if we are handling the same protocol
            # we noticed that using TCP to UDP conversion on BYE sent from the callee sometimes needs to re-initialize
            # a new tcp session
            if (has_totag() && ($(oP{s.tolower}) == $(dP{s.tolower}))) {
                set_forward_no_connect();
            }
        }
    }
#!endif
    return;
} # end route[NATMANAGE]

# -----------------------------------------------------------------------------
# route[DLGURI]
# URI update for dialog requests
# -----------------------------------------------------------------------------
route[DLGURI] {
#!ifdef WITH_NAT
    if (!isdsturiset()) {
        handle_ruri_alias();
    }
#!endif
    return;
} # end route[DLGURI]

# -----------------------------------------------------------------------------
# route[DISPATCHER_FAILURE]
# set inactive probing the actual $du and go to the next using re route(RELAY)
# -----------------------------------------------------------------------------
route[DISPATCHER_FAILURE]{
    xlog('L_WARN', "(route[DISPATCHER_FAILURE]) $ci $rm-$cs - DISPATCHER_FAILURE\n");
    if (!ds_next_dst()) {
        xlog('L_WARN', "(route[DISPATCHER_FAILURE]) $ci $rm-$cs - no further destinations to set, relaying back original reply \n");
        return;
    }
    xlog('L_WARN', "(route[DISPATCHER_FAILURE]) $ci $rm-$cs - du set to $du \n");
    route(RELAY);
} # end route[DISPATCHER_FAILURE]

# -----------------------------------------------------------------------------
# route[SET_CDR_VARS]
# set dlg vars for cdr_acc
# -----------------------------------------------------------------------------
route[SET_CDR_VARS] {
    if (is_request() && is_method("INVITE")) {
        $dlg_var(caller) = $fU;
        $dlg_var(callee) = $tU;
        $dlg_var(src_domain) = $fd;
        $dlg_var(dst_domain) = $rd;
        $dlg_var(src_ip) = $si;
        $dlg_var(method) = $rm;
        $dlg_var(callid) = $ci;
        $dlg_var(user_agent) = $ua;
        $dlg_var(destination_uri) = $du;
    }
} # end route[SET_CDR_VARS]

# -----------------------------------------------------------------------------
# route[ADD_X_REAL_IP]
# add header X-Forwarded-For
# -----------------------------------------------------------------------------
route[ADD_X_REAL_IP] {
    remove_hf("X-Real-IP");
    insert_hf("X-Real-IP: $si \r\n");
} # end route[ADD_X_REAL_IP]

# -----------------------------------------------------------------------------
# branch, onreply, failure Route definition
# -----------------------------------------------------------------------------
# branch_route[MANAGE_BRANCH]
# Manage outgoing branches
# -----------------------------------------------------------------------------
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    # rewriting request uri
    route(NATMANAGE);
} # end of branch_route[MANAGE_BRANCH]

# -----------------------------------------------------------------------------
# onreply_route[MANAGE_REPLY]
# Manage incoming replies in transaction context
# -----------------------------------------------------------------------------
onreply_route[MANAGE_REPLY] {
    if ($rs=~"[12][0-9][0-9]|488") {
        if($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in reply route (MANAGE_REPLY) and Response code is: $rs \n");
        # handling avp and dlg_var direction
        # printing $si 
        xlog('L_WARN', "[DEV] - $ci $rm-$cs - si: $si, rs: $rs \n");
        # $si is correctly set, to 10.5.4.1
        # setting direction in opposite (as it's a reply)
        if (is_in_subnet($si, INTERNAL_NETWORK) || $si == "127.0.0.1" ) {
            $avp(direction) = "in";
        } else {
            $avp(direction) = "out";
        }
        $dlg_var(direction) = $avp(direction);
        xlog('L_WARN', "[DEV] - $ci $rm-$cs - REPLY: Setting direction to :  $avp(direction)\n");
        
        route(NATMANAGE);
    }
} # end of onreply_route[MANAGE_REPLY]

# -----------------------------------------------------------------------------
# failure_route[MANAGE_FAILURE]
# Manage failure routing cases
# -----------------------------------------------------------------------------
failure_route[MANAGE_FAILURE] {
    if(t_check_status("488") && $dlg_var(SRTPTranscode) == "2") {
        xlog('L_WARN', "[DEV] - $ci $rm-$cs - in failure route because of 488 and transcode is: $dlg_var(SRTPTranscode) ru is : $ru\n");
        $avp(failure) = "1";
        append_branch();
        route(RELAY);
        exit;
    }
    # setting avp to notify we are in failure route
    $avp(failure) = "1";
    route(NATMANAGE);
    if (t_is_canceled()) {
        exit;
    }
    # If the direction call is in, then we need to send manage the DISPATCHER_FAILURE to activate the failover mechanism
    # otherwise we need to send a 408 to the client
    if ($avp(direction) == 'in' || $dlg_var(direction) == 'in') {
        if (is_method("BYE|INVITE|REGISTER") && (t_branch_timeout() and !t_branch_replied())) {
            xlog('L_WARN', "(failure_route[MANAGE_FAILURE]) $ci $rm-$cs - timeout with no reply, du was: $du customer:  $dlg_var(customer_id)\n");
            route(DISPATCHER_FAILURE);
        }
        if (t_check_status("5[0-9][0-9]") || t_check_status(DEFAULT_REPLY_CODE) || ( t_branch_timeout() && !t_branch_replied())) {
            route(DISPATCHER_FAILURE);
        }
    } else {
        if ((t_branch_timeout() and !t_branch_replied())) {
            t_reply("408","Request Timeout");
        }
    }
#!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
#!endif
#!ifdef WITH_BLOCK401407
    # block call redirect based on 401, 407 replies.
    if (t_check_status("401|407")) {
        t_reply("404","Not found");
        exit;
    }
#!endif
} # end of failure_route[MANAGE_FAILURE]

# -----------------------------------------------------------------------------
# event_route[topos:msg-sending]
# -----------------------------------------------------------------------------
event_route[topos:msg-sending] {
    if is_method("INVITE") {
      if($hdr(topos) == "0") {
        xlog('L_INFO', "(event_route[topos:msg-sending]) $ci $rm-$cs topos: $hdr(topos) ----- will not apply topos\n");
        remove_hf("topos");
        msg_apply_changes();
        drop;
      }
    }
    if ($rd!=$null) {
        if is_method("OPTIONS|NOTIFY|SUBSCRIBE") {
            drop;
        }
    }
} # end event_route[topos:msg-sending]

# -----------------------------------------------------------------------------
# event_route[xhttp:request]
# -----------------------------------------------------------------------------
event_route[xhttp:request] {
    if (src_ip!=127.0.0.1) {
        xhttp_reply("403", "Forbidden", "text/html",
            "<html><body>Not allowed from $si</body></html>");
        exit;
    }
    if ($hu =~ "^/RPC") {
        jsonrpc_dispatch();
    } else {
        xhttp_reply("200", "OK", "text/html",
            "<html><body>Wrong URL $hu</body></html>");
    }
    return;
} # end event_route[xhttp:request]

# -----------------------------------------------------------------------------
# route[REWRITE_USER_AGENT]
# rewrite user agent to SipFlare
# -----------------------------------------------------------------------------
route[REWRITE_USER_AGENT] {
    remove_hf("User-Agent");
    append_hf("User-Agent: "+KML_UA_HEADER+"\r\n","Call-ID");
} # end route[REWRITE_USER_AGENT]

# -----------------------------------------------------------------------------
# route[HEALTHCHECK]
# respond to options on localhost
# -----------------------------------------------------------------------------
route[HEALTHCHECK] {
    if (is_method("OPTIONS") && $si == "127.0.0.1") {
        route(KEEPALIVE);
    }
} # end route[HEALTHCHECK]

# -----------------------------------------------------------------------------
# route[HAVE_DISPLAY_NAME]
# Check if From header have Display Name ($fn)
# -----------------------------------------------------------------------------
route[HAVE_DISPLAY_NAME] {

    if ($fn != "" && $fn != 0 && $fn != $null) {
        return(1); # Positive is TRUE
    }
    return(-1);

}# end of route HAVE_DISPLAY_NAME

# -----------------------------------------------------------------------------
# route[BLOCKIP]
# with this route we block the ip address using APIBAN
# -----------------------------------------------------------------------------
route[BLOCKIP] {
    if (src_ip!=myself) {
        xlog("L_INFO","[R-BLOCKIP:$ci]: blocking $rm from $fu (IP:$si:$sp)\n");
        $avp(ipaddressToBan) = $si;
        route(ADD_TO_IPBAN);
        #$sht(ipban=>$si) = 1;
    }
    return;
} # end of route[BLOCKIP]

# -----------------------------------------------------------------------------
# route[ADD_TO_IPBAN]
# in this route we add the ipaddress defined in $avp(ipaddressToBan) for the ip address
# and the corresponding customer associated in $avp(customer_id)
# if customer_id is not set, then set 0 as customer id
# we will populate 2 shared tables, sht(ipban) and sht(customer_ipban) with this model
# $sht(ipban=>$ipAddress) = 1
# $sht(customer_ipban=>$customer_id-$ipAddress) = 1
# -----------------------------------------------------------------------------
route[ADD_TO_IPBAN] {
    # is customer_id set ?
    if ($avp(customer_id) == $null || $avp(customer_id) == 0 || $avp(customer_id) == "") {
        # customer id is not set so, forcing it to id: 0
        $avp(customer_id) = 0;
    }
    # do I have an ip address to add to ipban ?
    if ($avp(ipaddressToBan) != $null && $avp(ipaddressToBan) != 0 && $avp(ipaddressToBan) != "") {
        # ok adding to ipban shared table
        $sht(ipban=>$avp(ipaddressToBan)) = 1;
        $sht(customer_ipban=>$avp(customer_id)-$avp(ipaddressToBan)) = 1;
    }
} # end of route[ADD_TO_IPBAN]

# -----------------------------------------------------------------------------
# route[SET_TIMERS]
# this route set the timers for the call, using t_set_fr
# Sets the fr_inv_timeout and optionally fr_timeout for the current transaction or for transactions created during the same script invocation,
# after calling this function. If the transaction is already created (e.g called after t_relay() or in an onreply_route)
# all the branches will have their final response timeout updated on-the-fly. If one of the parameters is 0, its value won't be changed.
# - fr_inv_timeout - new final response timeout (in milliseconds) for INVITEs. See also fr_inv_timer.
# - fr_timeout - new final response timeout (in milliseconds) for non-INVITE transaction, or INVITEs which haven't received yet a provisional response. See also fr_timer.
# -----------------------------------------------------------------------------
route[SET_TIMERS] {
    # set the fr_inv_timeout
    t_set_fr(FR_INV_TIMEOUT, FR_TIMEOUT_100);
} # end of route[SET_TIMERS]

# -----------------------------------------------------------------------------
# route[REWRITE_CONTACT]
# this route rewrite the contact header
# -----------------------------------------------------------------------------
route[REWRITE_CONTACT] {
    $var(contactUriParameters) = $null;
    if(is_present_hf("contact")) {
        if($(ct{nameaddr.uri}{uri.user}) != $null && $(ct{nameaddr.uri}{uri.user}) != "" && $(ct{nameaddr.uri}{uri.user}) != 0) {
            $var(userInContact) = $(ct{nameaddr.uri}{uri.user});
        }
        if($(ct{nameaddr.uri}{uri.params}) != $null && $(ct{nameaddr.uri}{uri.params}) != "" && $(ct{nameaddr.uri}{uri.params}) != 0) {
            $var(contactUriParameters) = $(ct{nameaddr.uri}{uri.params});
        }
    }
    # rewrite the contact header
    # 1 - UDP
    # 2 - TCP
    # 3 - TLS
    $var(proto) = $null;
    $var(ctProto) = $null;
    $var(ctProto) = $(ct{nameaddr.uri}{uri.transport});
    switch ($var(ctProto)) {
        case "UDP":
            $var(proto) = "1";
            break;
        case "TCP":
            $var(proto) = "2";
            break;
        case "TLS":
            $var(proto) = "3";
            break;
        default:
            $var(proto) = "1";
            break;
    }
    # logging protocol
    // xlog('L_WARN', "[DEV] - $ci $rm-$cs - protocol: $var(ctProto), int proto: $var(proto) \n");
    remove_hf("Contact");
    $var(default_contact) = DEFAULT_CONTACT;
    append_hf("Contact: <sip:$fU@$var(default_contact);$var(contactUriParameters);alias=$si~$sp~$var(proto)>\r\n","Call-ID");
} # end of route[REWRITE_CONTACT]
# -----------------------------------------------------------------------------
# route[HANDLE_ALIAS]
# this route handles the alias
# -----------------------------------------------------------------------------
route[HANDLE_ALIAS] {
    handle_ruri_alias();
    if ($rc == 1) {
        if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - handle_ruri_alias returned 1, doing RELAY \n");
        route(SET_TIMERS);
        route(RELAY);
    }

} # end of route[HANDLE_ALIAS]

# -----------------------------------------------------------------------------
# route[SET_FROM_SOCKET]
# this route set the from socket accoding also to LOCALNETWORKS
# -----------------------------------------------------------------------------
route[SET_SOCKET] {
    if( $shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - in SET_SOCKET route \n");
    if(is_request()) {
        # print $rd is an ip and is in LOCALNETWORKS then print it
        $var(destination_ip)= $null; # reinitialize the variable
        $var(destination_ip) = $(ru{uri.host}); # fetch the destination ip from ru
        if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - destination ip: $var(destination_ip) \n");
        if ($var(destination_ip) != $null && $var(destination_ip) != 0 && $var(destination_ip) != "") {
            if (is_in_subnet($var(destination_ip), LOCALNETWORKS)) {
                if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - destination ip is in LOCALNETWORKS \n");
                $var(from_socket) = PRIVATE_IP;
                set_advertised_address(PRIVATE_IP);
                # logging I've set the PRIVATE IP
                if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - from_socket: $var(from_socket) \n");
                # handling rtpengine manage
                if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - rtpengine_conf: $var(rtpengine_conf) \n");
                # replace external in $var(rtpengine_conf) with local
                $var(rtpengine_conf) = $(var(rtpengine_conf){s.replace,external,local});
                # logging rtpengine_conf
                if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - rtpengine_conf: $var(rtpengine_conf) \n");
            }
        }
    } else {
        if(is_reply()){
            $var(destination_ip)= $null; # reinitialize the variable
            # logging $dlg_var(source_ip)
            if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - Original source ip: $dlg_var(source_ip) \n");
            # fetching destination ip from contact
            $var(destination_ip) = $dlg_var(source_ip);
            if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - destination ip: $var(destination_ip) \n");
            if ($var(destination_ip) != $null && $var(destination_ip) != 0 && $var(destination_ip) != "") {
                if (is_in_subnet($var(destination_ip), LOCALNETWORKS)) {
                    if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - destination ip is in LOCALNETWORKS \n");
                    # replace external in $var(rtpengine_conf) with local
                    $var(rtpengine_conf) = $(var(rtpengine_conf){s.replace,external,local});
                    # logging rtpengine_conf
                    if ($shv(debug) == 1) xlog('L_WARN', "[DEV] - $ci $rm-$cs - rtpengine_conf: $var(rtpengine_conf) \n");
                }
            }
        }
    }
}
